#!/usr/bin/env python
from time import time
from random import randint
from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
from xmlrpclib import Fault
import cPickle
from base64 import b64decode
import os
import sys
from netways_grapher import model, utils

print("NETWAYS Grapher V3 (backend daemon)")

class BackendRPCMethods:
    def __init__(self):
        self.hosts = {}
        self.services = {}
        self.hostservices = {}
        self.plots = {}
        
    def setupTimeFrame(self, interval, retention_period=None):
        tfs = model.TimeFrame.getAllSorted(conn, active_only=True)
         
        for tf in tfs:
            if (tf.interval < interval and interval % tf.interval != 0) or \
                    (tf.interval > interval and tf.interval % interval != 0):
                raise Fault(1, 'Timeframe interval is invalid. Must ' + \
                                 'be multiple of existing timeframe or ' + \
                                 'evenly divisible by existing larger intervals.')
                
            if tf.interval == interval:
                tf.retention_period = retention_period
                tf.save(conn)
                
                return tf.id
        
        tf = model.TimeFrame(interval, retention_period)
        tf.save(conn)
        
        return tf.id
    
    def getTimeFrames(self):
        tfs = model.TimeFrame.getAllSorted(conn, active_only=True)
        
        items = {}
        
        for tf in tfs:
            items[str(tf.interval)] = {'id': tf.id, 'interval': tf.interval, 'retention-period': tf.retention_period}
            
        return items
    
    def disableTimeFrame(self, tf_id):
        tf = model.TimeFrame.getByID(conn, tf_id)
        tf.active = False;
        tf.save(conn)

        return True

    # TODO: methods for enabling/disabling/listing timeframes

    def _createHost(self, name):
        if name in self.hosts:
            return self.hosts[name]
        
        obj = model.Host.getByName(conn, name)
        
        if obj == None:
            obj = model.Host(name)
            obj.save(conn)
            
        self.hosts[name] = obj
            
        return obj
    
    def _createService(self, name):
        if name in self.services:
            return self.services[name]

        obj = model.Service.getByName(conn, name)
        
        if obj == None:
            obj = model.Service(name)
            obj.save(conn)
        
        self.services[name] = obj
        
        return obj

    def _createHostService(self, host, service, parent_hostservice):
        hostservice_key = (host, service)
        
        if hostservice_key in self.hostservices:
            return self.hostservices[hostservice_key]
        
        obj = model.HostService.getByHostAndService(conn, host, service, parent_hostservice)
        
        if obj == None:
            obj = model.HostService(host, service, parent_hostservice)
            obj.save(conn)
        
        self.hostservices[hostservice_key] = obj
        
        return obj

    def _createPlot(self, hostservice, name):
        plot_key = (hostservice, name)
        
        if plot_key in self.plots:
            return self.plots[plot_key]
        
        obj = model.Plot.getByHostServiceAndName(conn, hostservice, name)
        
        if obj == None:        
            obj = model.Plot(hostservice, name)
            obj.save(conn)

        self.plots[plot_key] = obj

        return obj

    def insertValueBulk(self, updates_raw):
        updates = cPickle.loads(updates_raw)
        
        for update in updates:
            if len(update) > 11:
                (host, parent_service, service, plot, timestamp, unit, value, min, max, lower_limit, upper_limit, tf) = update
            else:
                (host, parent_service, service, plot, timestamp, unit, value, min, max, lower_limit, upper_limit) = update
                tf = None
            
            host_obj = self._createHost(host)
            if parent_service != None:
                parent_service_obj = self._createService(parent_service)
                parent_hostservice_obj = self._createHostService(host_obj, parent_service_obj, None)
            else:
                parent_hostservice_obj = None
            service_obj = self._createService(service)
            hostservice_obj = self._createHostService(host_obj, service_obj, parent_hostservice_obj)
            plot_obj = self._createPlot(hostservice_obj, plot)

            if tf == None:
                plot_obj.insertValue(conn, timestamp, unit, value, min, max, lower_limit, upper_limit)
            else:
                plot_obj.insertValueRaw(conn, tf, timestamp, unit, value, min, max, lower_limit, upper_limit)

        return True
    
    def getHosts(self):
        hosts = model.Host.getAll()
        
        items = []
        
        for host in hosts:
            items.append(host.name)
            
        return items
    
    def getHostsFiltered(self, pattern, limit, offset):
        hosts = model.Host.getByPattern(conn, pattern, limit, offset)
        
        items = []
        
        for host in hosts:
            items.append(host.name)
            
        return items

    def getPlots(self, host):
        items = []

        plots = model.Plot.getByHost(conn, host)

        for plot in plots:
            item = {
                'name': plot.name,
                'service': plot.hostservice.service.name
            }
            
            if plot.hostservice.parent_hostservice != None:
                item['parent_service'] = plot.hostservice.parent_hostservice.service.name
                
            items.append(item)
        
        return items
    
    def getPlotValues(self, host, parent_service, service, plot, start_timestamp, end_timestamp, granularity):
        host_obj = model.Host.getByName(conn, host)
        
        if host == None:
            return []

        service_obj = model.Service.getByName(conn, service)
        
        if service_obj == None:
            return []
        
        if parent_service != None and parent_service != '':
            parent_service_obj = model.Service.getByName(conn, parent_service)
            
            if parent_service_obj == None:
                return []
            
            parent_hostservice_obj = model.HostService.getByHostAndService(conn, host_obj, parent_service_obj, None)
        else:
            parent_hostservice_obj = None
            
        hostservice_obj = model.HostService.getByHostAndService(conn, host_obj, service_obj, parent_hostservice_obj)
        
        if hostservice_obj == None:
            return []
        
        plot_obj = model.Plot.getByHostServiceAndName(conn, hostservice_obj, plot)
        
        if plot_obj == None:
            return []

        return model.DataPoint.getValuesByInterval(conn, plot_obj, start_timestamp,
                                                   end_timestamp, granularity)
    
    def sync(self):
        model.sync_model_session(conn)

        return True
    
    def shutdown(self):
        global shutdown_server
        
        # make sure everything's synced before returning from
        # the xmlrpc call
        self.sync()
        
        shutdown_server = True
        
        return True

# http://www.acooke.org/cute/BasicHTTPA0.html
class AuthenticatedXMLRPCServer(SimpleXMLRPCServer):
    def __init__(self, *args, **kargs):
        class AuthenticatedRequestHandler(SimpleXMLRPCRequestHandler):
            def parse_request(myself):
                if SimpleXMLRPCRequestHandler.parse_request(myself):
                    header = myself.headers.get('Authorization')
                    
                    if header == None:
                        username = None
                        password = None
                    else:                    
                        (basic, encoded) = \
                            header.split(' ', 2)
    
                        assert basic == 'Basic', 'Only basic authentication supported'
                        
                        (username, password) = b64decode(encoded).split(':', 2)
                    
                    if self.authenticate(username, password):
                        return True
                    else:
                        myself.send_response(401, 'Authentication failed')
                        myself.send_header('WWW-Authenticate', 'Basic realm="XML-RPC"')
                        myself.end_headers()
                        
                        myself.wfile.write('Authentication failed.')
                
                return False
        
        SimpleXMLRPCServer.__init__(self, requestHandler=AuthenticatedRequestHandler, *args, **kargs)

        self.required_username = None
        self.required_password = None

    def authenticate(self, username, password):
        if self.required_username == None and self.required_password == None:
            return True
        
        return self.required_username == username and self.required_password == password

config = utils.load_config('grapher-database.conf')
config = utils.load_config('grapher-xmlrpc.conf', config)

if config['dsn'] == None:
    print("Error: You need to set a database connection string ('dsn' setting)" + \
          " in your configuration file.")
    sys.exit(1)

print('Connecting to the database...')
conn = model.create_model_conn(config['dsn'])

if 'xmlrpc_address' not in config or 'xmlrpc_port' not in config:
    print("Error: You need to set a bind address/port for the XML-RPC" + \
          " interface ('xmlrpc_address' and 'xmlrpc_port' settings).")
    sys.exit(1)
    
print('Starting XML-RPC interface on %s:%d...' % (config['xmlrpc_address'], config['xmlrpc_port']))
server = AuthenticatedXMLRPCServer((config['xmlrpc_address'], config['xmlrpc_port']))
server.timeout = 5

if sys.version_info[:2] < (2,6):
    server.socket.settimeout(server.timeout)

if 'xmlrpc_username' not in config or 'xmlrpc_password' not in config:
    print("Error: You need to set an XML-RPC username and password ('xmlrpc_username'" + \
          " and 'xmlrpc_password' settings) in your configuration file.")
    sys.exit(1)

server.required_username = config['xmlrpc_username']
server.required_password = config['xmlrpc_password']

server.register_introspection_functions()
server.register_multicall_functions()
backend_obj = BackendRPCMethods()
server.register_instance(backend_obj)

last_maintenance = time()

try:
    shutdown_server = False

    print("Waiting for XML-RPC requests...")

    while not shutdown_server:
        server.handle_request()
        
        st = time()
        model.sync_model_session(conn, partial_sync=True)
        et = time()
        print("partial sync took %f seconds" % (et - st))
        
        model.run_maintenance_tasks(conn)
except KeyboardInterrupt:
    print('Syncing all remaining objects - Please wait...')
    model.sync_model_session(conn)