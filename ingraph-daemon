#!/usr/bin/env python
import time
from fnmatch import fnmatch
from random import randint
from SocketServer import ThreadingTCPServer
from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCDispatcher, SimpleXMLRPCRequestHandler
import xmlrpclib
from xmlrpclib import Fault, Marshaller
import cPickle
from base64 import b64decode
import os
import sys
from netways_ingraph import model, utils
import traceback
import Queue
from threading import Thread

class _xmldumps(object):

    def __init__(self, dumps):
        self.__dumps = (dumps,)

    def __call__(self, *args, **kwargs):
        kwargs.setdefault('allow_none', 1)
        return self.__dumps[0](*args, **kwargs)

xmlrpclib.dumps = _xmldumps(xmlrpclib.dumps)

print("NETWAYS inGraph (backend daemon)")

class BackendRPCMethods:
    def __init__(self):
        self.hosts = {}
        self.services = {}
        self.hostservices = {}
        self.plots = {}
        
    def setupTimeFrame(self, interval, retention_period=None):
        tfs = model.TimeFrame.getAll(engine)
         
        for tf in tfs:
            if (tf.interval < interval and interval % tf.interval != 0) or \
                    (tf.interval > interval and tf.interval % interval != 0):
                raise Fault(1, 'Timeframe interval is invalid. Must ' + \
                                 'be multiple of existing timeframe or ' + \
                                 'evenly divisible by existing larger intervals.')
                
            if tf.interval == interval:
                tf.retention_period = retention_period
                tf.save(engine)
                
                return tf.id
        
        tf = model.TimeFrame(interval, retention_period)
        tf.save(engine)
        
        return tf.id
    
    def getTimeFrames(self):
        tfs = model.TimeFrame.getAll(engine)
        
        items = {}
        
        for tf in tfs:
            items[str(tf.interval)] = {'id': tf.id, 'interval': tf.interval, 'retention-period': tf.retention_period}
            
        return items
    
    def disableTimeFrame(self, tf_id):
        tf = model.TimeFrame.getByID(engine, tf_id)
        tf.active = False;
        tf.save(engine)

        return True

    # TODO: methods for enabling/disabling/listing timeframes

    def _createHost(self, conn, name):
        if name in self.hosts:
            return self.hosts[name]
        
        obj = model.Host.getByName(conn, name)
        
        if obj == None:
            obj = model.Host(name)
            obj.save(conn)
            
        self.hosts[name] = obj
            
        return obj
    
    def _createService(self, conn, name):
        if name in self.services:
            return self.services[name]

        obj = model.Service.getByName(conn, name)
        
        if obj == None:
            obj = model.Service(name)
            obj.save(conn)
        
        self.services[name] = obj
        
        return obj

    def _createHostService(self, conn, host, service, parent_hostservice):
        hostservice_key = (host, service)
        
        if hostservice_key in self.hostservices:
            return self.hostservices[hostservice_key]
        
        objs = model.HostService.getByHostAndService(conn, host, service, parent_hostservice)
        
        if len(objs) == 0:
            obj = model.HostService(host, service, parent_hostservice)
            obj.save(conn)
        else:
            obj = objs[0]
            
        self.hostservices[hostservice_key] = obj
        
        return obj

    def _createPlot(self, conn, hostservice, name):
        plot_key = (hostservice, name)
        if plot_key in self.plots:
            return self.plots[plot_key]
        
        objs = model.Plot.getByHostServiceAndName(conn, hostservice, name)
        
        if len(objs) == 0:    
            obj = model.Plot(hostservice, name)
            obj.save(conn)
        else:
            obj = objs[0]

        self.plots[plot_key] = obj

        return obj

    def insertValueBulk(self, updates_raw):
        updates = cPickle.loads(updates_raw)
        
        conn = engine.connect()
        transaction = conn.begin()
        
        for update in updates:
            (host, parent_service, service, plot, timestamp, unit, value, \
             min, max, lower_limit, upper_limit, warn_lower, warn_upper, warn_type, \
             crit_lower, crit_upper, crit_type) = update
            
            host_obj = self._createHost(conn, host)
            if parent_service != None:
                parent_service_obj = self._createService(conn, parent_service)
                parent_hostservice_obj = self._createHostService(conn, host_obj, parent_service_obj, None)
            else:
                parent_hostservice_obj = None
            service_obj = self._createService(conn, service)

            hostservice_obj = self._createHostService(conn, host_obj, service_obj, parent_hostservice_obj)
            plot_obj = self._createPlot(conn, hostservice_obj, plot)

            queries = plot_obj.buildUpdateQueries(conn, timestamp, unit, value,
                                 min, max, lower_limit, upper_limit,
                                 warn_lower, warn_upper, warn_type,
                                 crit_lower, crit_upper, crit_type)
            
            for query in queries:
                queryqueue.put(query)
        
        transaction.commit()
        conn.close()

        return True

    def getHosts(self):
        hosts = model.Host.getAll(engine)
        
        items = []
        
        for host in hosts:
            items.append(host.name)
            
        return items
    
    def getHostsFiltered(self, pattern, limit=None, offset=None):
        result = model.Host.getByPattern(engine, pattern.replace('*', '%'), limit, offset)
        
        items = []
        
        for host in result['hosts']:
            items.append(host.name)
            
        return {'total': result['total'], 'hosts': items}

    def getServices(self, host_pattern, service_pattern=None, limit=None, offset=None):
	result = model.HostService.getByHostAndServicePattern(engine, host_pattern.replace('*', '%'),
								service_pattern.replace('*', '%'), limit, offset)

        items = set()

        for hostservice_obj in result['services']:
            items.add(hostservice_obj.service.name)
        
        return {'total': result['total'], 'services': list(items)}
    
    def getPlotValues(self, host_pattern, service_pattern, start_timestamp=None, end_timestamp=None, granularity=None, null_tolerance=0):
        charts = []
        comments = []
        result = { 'comments': comments, 'charts': charts }
        
        if host_pattern != None:
            host_pattern = host_pattern.replace('*', '%')
        
        if service_pattern != None:
            service_pattern = service_pattern.replace('*', '%')
        
        if start_timestamp == '':
            start_timestamp = None
            
        if end_timestamp == '':
            end_timestamp = None
            
        if granularity == '':
            granularity = None

        result_services = model.HostService.getByHostAndServicePattern(engine, host_pattern, service_pattern)

        for hostservice_obj in result_services['services']:        
            plot_objs = model.Plot.getByHostServiceAndName(engine, hostservice_obj, None)
                
            dps = model.DataPoint.getValuesByInterval(engine, plot_objs, start_timestamp,
                                                         end_timestamp, granularity, null_tolerance)

            comments.extend(dps['comments'])

            for plot_obj, plot_charts in dps['charts'].iteritems():
                for type, data in plot_charts.iteritems():
                    label = plot_obj.name + '-' + type
                    
                    if hostservice_obj.parent_hostservice != None:
                        label = hostservice_obj.service.name + '-' + label
                    
                    charts.append({'host': hostservice_obj.host.name, 'service': hostservice_obj.service.name, 
                                   'label': label, 'unit': plot_obj.unit, 'data': data})

        st = time.time()
        et = time.time()
        
        print "Got plot values in %f seconds" % (et - st)
        return result
 
    def shutdown(self):
        global shutdown_server
        
        shutdown_server = True
        
        return True
    
    def addComment(self, host, parent_service, service, timestamp, author, text):
        host_obj = self._createHost(conn, host)
        if parent_service != None:
            parent_service_obj = self._createService(conn, parent_service)
            parent_hostservice_obj = self._createHostService(conn, host_obj, parent_service_obj, None)
        else:
            parent_hostservice_obj = None
        service_obj = self._createService(conn, service)

        hostservice_obj = self._createHostService(conn, host_obj, service_obj, parent_hostservice_obj)

        comment = Comment(hostservice_obj, timestamp, author, text)
        comment.save(engine)

        return comment.id
    
    def deleteComment(self, comment_id):
        comment = Comment.getByID(engine, comment_id)
        comment.delete(engine)
    
    def updateComment(self, comment_id, text):
        comment = Comment.getByID(engine, comment_id)
        comment.text = text
        comment.save()

# http://www.acooke.org/cute/BasicHTTPA0.html
class AuthenticatedXMLRPCServer(ThreadingTCPServer, SimpleXMLRPCDispatcher):
    allow_reuse_address = 1

    def __init__(self, addr, allow_none=False, logRequests=1, encoding='iso-8859-1'):
        class AuthenticatedRequestHandler(SimpleXMLRPCRequestHandler):
            def parse_request(myself):
                if SimpleXMLRPCRequestHandler.parse_request(myself):
                    header = myself.headers.get('Authorization')
                    
                    if header == None:
                        username = None
                        password = None
                    else:                    
                        (basic, encoded) = \
                            header.split(' ', 2)
    
                        assert basic == 'Basic', 'Only basic authentication supported'
                        
                        (username, password) = b64decode(encoded).split(':', 2)
                    
                    if self.authenticate(username, password):
                        return True
                    else:
                        myself.send_response(401, 'Authentication failed')
                        myself.send_header('WWW-Authenticate', 'Basic realm="XML-RPC"')
                        myself.end_headers()
                        
                        myself.wfile.write('Authentication failed.')
                
                return False
        
        self.logRequests = logRequests
        
        if sys.version_info[:2] < (2, 5):
            SimpleXMLRPCDispatcher.__init__(self)
        else:
            SimpleXMLRPCDispatcher.__init__(self, allow_none=allow_none, encoding=encoding)
            
        ThreadingTCPServer.__init__(self, addr, AuthenticatedRequestHandler)

        self.required_username = None
        self.required_password = None

    def authenticate(self, username, password):
        if self.required_username == None and self.required_password == None:
            return True
        
        return self.required_username == username and self.required_password == password

config = utils.load_config('ingraph-database.conf')
config = utils.load_config('ingraph-xmlrpc.conf', config)

if config['dsn'] == None:
    print("Error: You need to set a database connection string ('dsn' setting)" + \
          " in your configuration file.")
    sys.exit(1)

print('Connecting to the database...')
engine = model.createModelEngine(config['dsn'])

if 'xmlrpc_address' not in config or 'xmlrpc_port' not in config:
    print("Error: You need to set a bind address/port for the XML-RPC" + \
          " interface ('xmlrpc_address' and 'xmlrpc_port' settings).")
    sys.exit(1)

queryqueue = Queue.Queue(maxsize=200000)

def flushDBThread(engine):
    while True:
        items = []

        print "Queue size: %d" % (queryqueue.qsize())

        while len(items) < 5000:
            try:
                item = queryqueue.get(timeout=10)
            except Queue.Empty:
                break

            items.append(item)

        st = time.time()
        conn = engine.connect()
        transaction = conn.begin()        
        model.Plot.executeUpdateQueries(conn, items)
        transaction.commit()
        conn.close()
        et = time.time()
        
        print "Flushed %d updates in %f seconds." % (len(items), et - st)

flushthread = Thread(target=flushDBThread, args=(engine,))
flushthread.daemon = True
flushthread.start()

print('Starting XML-RPC interface on %s:%d...' % (config['xmlrpc_address'], config['xmlrpc_port']))
server = AuthenticatedXMLRPCServer((config['xmlrpc_address'], config['xmlrpc_port']), allow_none=True)
server.timeout = 5

if sys.version_info[:2] < (2,6):
    server.socket.settimeout(server.timeout)

if 'xmlrpc_username' not in config or 'xmlrpc_password' not in config:
    print("Error: You need to set an XML-RPC username and password ('xmlrpc_username'" + \
          " and 'xmlrpc_password' settings) in your configuration file.")
    sys.exit(1)

server.required_username = config['xmlrpc_username']
server.required_password = config['xmlrpc_password']

server.register_introspection_functions()
server.register_multicall_functions()
server.register_instance(BackendRPCMethods())

shutdown_server = False

print("Waiting for XML-RPC requests...")

while not shutdown_server:
    server.handle_request()
    model.runMaintenanceTasks(engine)
