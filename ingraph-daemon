#!/usr/bin/env python
from time import time
from fnmatch import fnmatch
from random import randint
from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler
import xmlrpclib
from xmlrpclib import Fault, Marshaller
import cPickle
from base64 import b64decode
import os
import sys
from netways_ingraph import model, utils

print("NETWAYS inGraph (backend daemon)")

class BackendRPCMethods:
    def __init__(self):
        self.hosts = {}
        self.services = {}
        self.hostservices = {}
        self.plots = {}
        
    def setupTimeFrame(self, interval, retention_period=None):
        tfs = model.TimeFrame.getAllSorted(conn, active_only=True)
         
        for tf in tfs:
            if (tf.interval < interval and interval % tf.interval != 0) or \
                    (tf.interval > interval and tf.interval % interval != 0):
                raise Fault(1, 'Timeframe interval is invalid. Must ' + \
                                 'be multiple of existing timeframe or ' + \
                                 'evenly divisible by existing larger intervals.')
                
            if tf.interval == interval:
                tf.retention_period = retention_period
                tf.save(conn)
                
                return tf.id
        
        tf = model.TimeFrame(interval, retention_period)
        tf.save(conn)
        
        return tf.id
    
    def getTimeFrames(self):
        tfs = model.TimeFrame.getAllSorted(conn, active_only=True)
        
        items = {}
        
        for tf in tfs:
            items[str(tf.interval)] = {'id': tf.id, 'interval': tf.interval, 'retention-period': tf.retention_period}
            
        return items
    
    def disableTimeFrame(self, tf_id):
        tf = model.TimeFrame.getByID(conn, tf_id)
        tf.active = False;
        tf.save(conn)

        return True

    # TODO: methods for enabling/disabling/listing timeframes

    def _createHost(self, name):
        if name in self.hosts:
            return self.hosts[name]
        
        obj = model.Host.getByName(conn, name)
        
        if obj == None:
            obj = model.Host(name)
            obj.save(conn)
            
        self.hosts[name] = obj
            
        return obj
    
    def _createService(self, name):
        if name in self.services:
            return self.services[name]

        obj = model.Service.getByName(conn, name)
        
        if obj == None:
            obj = model.Service(name)
            obj.save(conn)
        
        self.services[name] = obj
        
        return obj

    def _createHostService(self, host, service, parent_hostservice):
        hostservice_key = (host, service)
        
        if hostservice_key in self.hostservices:
            return self.hostservices[hostservice_key]
        
        objs = model.HostService.getByHostAndService(conn, host, service, parent_hostservice)
        
        if len(objs) == 0:
            obj = model.HostService(host, service, parent_hostservice)
            obj.save(conn)
        else:
            obj = objs[0]
            
        self.hostservices[hostservice_key] = obj
        
        return obj

    def _createPlot(self, hostservice, name):
        plot_key = (hostservice, name)
        if plot_key in self.plots:
            return self.plots[plot_key]
        
        objs = model.Plot.getByHostServiceAndName(conn, hostservice, name)
        
        if len(objs) == 0:    
            obj = model.Plot(hostservice, name)
            obj.save(conn)
        else:
            obj = objs[0]

        self.plots[plot_key] = obj

        return obj

    def insertValueBulk(self, updates_raw):
        updates = cPickle.loads(updates_raw)
        
        for update in updates:
            if len(update) > 17:
                (host, parent_service, service, plot, timestamp, unit, value, \
                 min, max, lower_limit, upper_limit, warn_lower, warn_upper, warn_type, \
                 crit_lower, crit_upper, crit_type, tf) = update
            else:
                (host, parent_service, service, plot, timestamp, unit, value, \
                 min, max, lower_limit, upper_limit, warn_lower, warn_upper, warn_type, \
                 crit_lower, crit_upper, crit_type) = update
                tf = None
            
            host_obj = self._createHost(host)
            if parent_service != None:
                parent_service_obj = self._createService(parent_service)
                parent_hostservice_obj = self._createHostService(host_obj, parent_service_obj, None)
            else:
                parent_hostservice_obj = None
            service_obj = self._createService(service)

            hostservice_obj = self._createHostService(host_obj, service_obj, parent_hostservice_obj)
            plot_obj = self._createPlot(hostservice_obj, plot)

            if tf == None:
                plot_obj.insertValue(conn, timestamp, unit, value,
                                     min, max, lower_limit, upper_limit,
                                     warn_lower, warn_upper, warn_type,
                                     crit_lower, crit_upper, crit_type)
            else:
                plot_obj.insertValueRaw(conn, tf, timestamp, unit, value, 
                                        min, max, lower_limit, upper_limit,
                                        warn_lower, warn_upper, warn_type,
                                        crit_lower, crit_upper, crit_type)
             
        return True
    
    def getHosts(self):
        hosts = model.Host.getAll(conn)
        
        items = []
        
        for host in hosts:
            items.append(host.name)
            
        return items
    
    def getHostsFiltered(self, pattern, limit=None, offset=None):
        result = model.Host.getByPattern(conn, pattern.replace('*', '%'), limit, offset)
        
        items = []
        
        for host in result['hosts']:
            items.append(host.name)
            
        return {'total': result['total'], 'hosts': items}

    def getServices(self, host_pattern, service_pattern=None, limit=None, offset=None):
	result = model.HostService.getByHostAndServicePattern(conn, host_pattern.replace('*', '%'),
								service_pattern.replace('*', '%'), limit, offset)

        items = set()

        for hostservice_obj in result['services']:
            items.add(hostservice_obj.service.name)
        
        return {'total': result['total'], 'services': list(items)}
    
    def getPlotValues(self, host_pattern, service_pattern, start_timestamp=None, end_timestamp=None, granularity=None):
        charts = []
        result = { 'charts': charts }
        
        if host_pattern != None:
            host_pattern = host_pattern.replace('*', '%')
        
        if service_pattern != None:
            service_pattern = service_pattern.replace('*', '%')
        
        if start_timestamp == '':
            start_timestamp = None
            
        if end_timestamp == '':
            end_timestamp = None
            
        if granularity == '':
            granularity = None

        result_services = model.HostService.getByHostAndServicePattern(conn, host_pattern, service_pattern)

        for hostservice_obj in result_services['services']:        
            plot_objs = model.Plot.getByHostServiceAndName(conn, hostservice_obj, None)
                  
            for plot_obj in plot_objs:
                values = model.DataPoint.getValuesByInterval(conn, plot_obj, start_timestamp,
                                                             end_timestamp, granularity)
                current_charts = {}

                for ts, value in values.items():
                    for type in ['upper_limit', 'max', 'avg', 'min', 'lower_limit',
                                 'warn_lower', 'warn_upper', 'warn_type', 'crit_lower',
                                 'crit_upper', 'crit_type']:
                        if not type in current_charts:
                            current_charts[type] = []
                        
                        item = {'x': ts}
                        
                        if not type in value:
                            item['y'] = False
                        else:
                            item['y'] = value[type]
                            
                            current_charts[type].append(item)
                
                for type, chart in current_charts.items():
                    label = plot_obj.name + '-' + type
                    
                    if hostservice_obj.parent_hostservice != None:
                        label = hostservice_obj.service.name + '-' + label
                    
                    charts.append({'host': hostservice_obj.host.name, 'service': hostservice_obj.service.name, 
                                   'label': label, 'unit': plot_obj.unit, 'values': chart})
                
        return result
    
    def sync(self):
        model.syncModelSession(conn)

        return True
    
    def shutdown(self):
        global shutdown_server
        
        # make sure everything's synced before returning from
        # the xmlrpc call
        self.sync()
        
        shutdown_server = True
        
        return True

# http://www.acooke.org/cute/BasicHTTPA0.html
class AuthenticatedXMLRPCServer(SimpleXMLRPCServer):
    def __init__(self, *args, **kargs):
        class AuthenticatedRequestHandler(SimpleXMLRPCRequestHandler):
            def parse_request(myself):
                if SimpleXMLRPCRequestHandler.parse_request(myself):
                    header = myself.headers.get('Authorization')
                    
                    if header == None:
                        username = None
                        password = None
                    else:                    
                        (basic, encoded) = \
                            header.split(' ', 2)
    
                        assert basic == 'Basic', 'Only basic authentication supported'
                        
                        (username, password) = b64decode(encoded).split(':', 2)
                    
                    if self.authenticate(username, password):
                        return True
                    else:
                        myself.send_response(401, 'Authentication failed')
                        myself.send_header('WWW-Authenticate', 'Basic realm="XML-RPC"')
                        myself.end_headers()
                        
                        myself.wfile.write('Authentication failed.')
                
                return False
        
        SimpleXMLRPCServer.__init__(self, requestHandler=AuthenticatedRequestHandler, *args, **kargs)

        self.required_username = None
        self.required_password = None

    def authenticate(self, username, password):
        if self.required_username == None and self.required_password == None:
            return True
        
        return self.required_username == username and self.required_password == password

if sys.version_info[:2] < (2,5):
    class AllowNoneMarshaller(Marshaller):
        def __init__(self, encoding=None, allow_none=0):
            Marshall.__init__(self, encoding, allow_none)
            self.allow_none = 1

    xmlrpclib.FastMarshaller = None
    xmlrpclib.Marshaller = AllowNoneMarshaller

config = utils.load_config('ingraph-database.conf')
config = utils.load_config('ingraph-xmlrpc.conf', config)

if config['dsn'] == None:
    print("Error: You need to set a database connection string ('dsn' setting)" + \
          " in your configuration file.")
    sys.exit(1)

print('Connecting to the database...')
conn = model.createModelConnection(config['dsn'])

if 'xmlrpc_address' not in config or 'xmlrpc_port' not in config:
    print("Error: You need to set a bind address/port for the XML-RPC" + \
          " interface ('xmlrpc_address' and 'xmlrpc_port' settings).")
    sys.exit(1)
    
print('Starting XML-RPC interface on %s:%d...' % (config['xmlrpc_address'], config['xmlrpc_port']))
server = AuthenticatedXMLRPCServer((config['xmlrpc_address'], config['xmlrpc_port']), allow_none=True)
server.timeout = 5

if sys.version_info[:2] < (2,6):
    server.socket.settimeout(server.timeout)

if 'xmlrpc_username' not in config or 'xmlrpc_password' not in config:
    print("Error: You need to set an XML-RPC username and password ('xmlrpc_username'" + \
          " and 'xmlrpc_password' settings) in your configuration file.")
    sys.exit(1)

server.required_username = config['xmlrpc_username']
server.required_password = config['xmlrpc_password']

server.register_introspection_functions()
server.register_multicall_functions()
backend_obj = BackendRPCMethods()
server.register_instance(backend_obj)

last_maintenance = time()

try:
    shutdown_server = False

    print("Waiting for XML-RPC requests...")

    while not shutdown_server:
        server.handle_request()
        
        st = time()
        model.syncModelSession(conn, partial_sync=True)
        et = time()
        print("partial sync took %f seconds" % (et - st))
        
        model.runMaintenanceTasks(conn)
except KeyboardInterrupt:
    print('Syncing all remaining objects - Please wait...')
    model.syncModelSession(conn)
